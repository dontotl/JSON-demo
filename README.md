# JSON demo Hands-on Guide


이 문서는 **Oracle JSON Duality View**를 처음 실습하는 사람을 위한 순서별 주석이 포함된 예제입니다.  
순서대로 복사&붙여넣기로 따라하시면 됩니다.

---

|항목|내용|설명|
|------|---|---|
|유저|user01 ~ user02|접속용|
|접속주소| <기본주소>/userxx/_sdw |예시) user01 이면 <기본주소>/user01/_sdw |

---

- 데모 유저 관리 그라운드 룰
    - 접근제어는 ID/Password 로 수행
    - 데모용 유저는 DB profile로 권한을 제한
        - 데모 유저 접속은 당일만 허용
        - 하루 지나면 lock 걸어두거나 DB를 내려놓음
        - 접속 후 120분 간 세션 유지
        - 30분간 idle시 접속 해제
        - 5회 로그인 실패 시 계정 잠김
        - 패스워드 리셋 시 동일 패스워드 재사용 3회 허용
        - USERS와 DATA TBS에 200MB의 공간만 허용
    - ORDS 유저를 활성화해서 웹브라우저만 준비되면 테스트 수행가능

---

## 1️⃣ 스키마 생성

```sql
-- (1) 고객 정보를 저장할 테이블 생성
CREATE TABLE customers (
  customer_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name        VARCHAR2(100) NOT NULL,
  email       VARCHAR2(200) UNIQUE,
  phone       VARCHAR2(40),
  created_at  TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- (2) 주문 정보를 저장할 테이블 생성 (고객 테이블 참조)
CREATE TABLE orders (
  order_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  customer_id  NUMBER NOT NULL REFERENCES customers(customer_id),
  order_date   DATE   DEFAULT SYSDATE,
  status       VARCHAR2(20) CHECK (status IN ('NEW','PAID','SHIPPED','CANCELLED'))
);

-- (3) 주문 상세(아이템) 테이블 생성 (주문 테이블 참조)
CREATE TABLE order_items (
  order_item_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id      NUMBER NOT NULL REFERENCES orders(order_id),
  product_sku   VARCHAR2(40) NOT NULL,
  qty           NUMBER CHECK (qty>0),
  unit_price    NUMBER(10,2) CHECK (unit_price>=0)
);

-- (4) 테스트용 기본 데이터 삽입
INSERT INTO customers(name,email,phone) VALUES ('Alice','alice@example.com','010-1111-1111');
INSERT INTO customers(name,email,phone) VALUES ('Bob','bob@example.com','010-2222-2222');
INSERT INTO orders(customer_id,status) VALUES (1,'NEW');
INSERT INTO orders(customer_id,status) VALUES (2,'PAID');
INSERT INTO order_items(order_id,product_sku,qty,unit_price) VALUES (1,'SKU-100',2,19.99);
INSERT INTO order_items(order_id,product_sku,qty,unit_price) VALUES (1,'SKU-200',1,49.00);
INSERT INTO order_items(order_id,product_sku,qty,unit_price) VALUES (2,'SKU-300',3,9.90);
COMMIT;

-- (5) Duality View 생성 (JSON과 관계형 데이터를 연결)
CREATE or replace JSON RELATIONAL DUALITY VIEW orders_dv AS
  customers @insert @update @delete 
    {
      _id        : customer_id,
      name       : name,
      email      : email,
      phone      : phone,
      created_at : created_at,
      orders : orders @insert @update @delete 
        {
          _id       : order_id,
          orderDate : order_date,
          status    : status,
          items : order_items @insert @update @delete 
            {
              _id       : order_item_id,
              sku       : product_sku,
              quantity  : qty,
              unitPrice : unit_price
            }
        }
    };
```
## 2️⃣ Duality View 조회 및 조작

```sql

prompt "Query duality view"

-- (6) JSON 형태로 데이터 조회 (연결된 모든 테이블 내용 포함)
SELECT * FROM orders_dv;

prompt "Insert via duality view"
-- (7) JSON 문서를 통해 새로운 고객 및 주문을 동시에 삽입
INSERT INTO orders_dv VALUES ('{
  "name":"Carol",
  "email":"carol@example.com",
  "orders":[{
             "status":"NEW",
             "items":[{
                       "sku":"SKU-500",
                       "quantity":2,
                       "unitPrice":15.5
                      }]
            }]
}');
COMMIT;

prompt "Query duality view & tables"
-- (8) Duality View와 실제 테이블 비교 조회
select * from orders_dv;
select * from customers;
select * from orders;
select * from order_items;

prompt "Update via duality view"
-- (9) JSON 변환 함수를 이용하여 Carol의 주문 상태를 변경
UPDATE orders_dv dv  SET data = json_transform(DATA, SET '$.orders[0].status' = 'SHIPPED')
WHERE dv.data.name = 'Carol';
COMMIT;

prompt "Query duality view & tables"
-- (10) 상태가 정상적으로 반영되었는지 확인
select * from orders_dv;
select * from customers;
select * from orders;
select * from order_items;

prompt "Delete via duality view"
-- (11) JSON 조건을 이용하여 Carol 고객 삭제
DELETE FROM orders_dv dv WHERE dv.DATA.name = 'Carol';
COMMIT;

prompt "Query duality view & tables"
-- (12) 삭제 결과를 Duality View와 테이블 양쪽에서 확인
select * from orders_dv;
select * from customers;
select * from orders;
select * from order_items;
```

## 3️⃣ 읽기 전용 Duality View 테스트

```sql

prompt "Read Only Duality view"

-- (13) DML 어노테이션을 제거하여, 조회 전용 Duality View 생성
CREATE or replace JSON RELATIONAL DUALITY VIEW orders_dv AS
  customers 
    {
      _id        : customer_id,
      name       : name,
      email      : email,
      phone      : phone,
      created_at : created_at,
      orders : orders 
        {
          _id       : order_id,
          orderDate : order_date,
          status    : status,
          items : order_items  
            {
              _id       : order_item_id,
              sku       : product_sku,
              quantity  : qty,
              unitPrice : unit_price
            }
        }
    };
    
-- (14) 읽기 전용 Duality View에 삽입 시도 (오류 발생 예상)
INSERT INTO orders_dv VALUES ('{
  "name":"Carol",
  "email":"carol@example.com",
  "orders":[{
             "status":"NEW",
             "items":[{
                       "sku":"SKU-500",
                       "quantity":2,
                       "unitPrice":15.5
                      }]
            }]
}');
COMMIT;    

prompt "test done."
```

## ✅ 정리

JSON Duality View는 JSON 문서 기반으로 관계형 데이터를 직접 조작할 수 있는 Oracle의 기능입니다.

@insert, @update, @delete 옵션을 통해 양방향 수정 가능한 뷰를 정의할 수 있습니다.

마지막 실습 파트에서는 읽기 전용 뷰를 생성하여 동작 차이를 확인합니다.


